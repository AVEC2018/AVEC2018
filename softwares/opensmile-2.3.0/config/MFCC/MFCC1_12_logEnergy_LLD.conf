
///////////////////////////////////////////////////////////////////////////////////////
///////// > openSMILE configuration file to extract MFCC features <  //////////////////
/////////   HTK target kind: MFCC_E_D_A, numCeps=12                  //////////////////
/////////                                                            //////////////////
/////////  * written 2009 by Florian Eyben *                         //////////////////
/////////                                                            //////////////////
///////// (c) audEERING UG (haftungsbeschränkt),                     //////////////////
/////////     All rights reserverd.                                  //////////////////
///////////////////////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////////////////////
;
; This section is always required in openSMILE configuration files
;   it configures the componentManager and gives a list of all components which are to be loaded
; The order in which the components are listed should match 
;   the order of the data flow for most efficient processing
;
///////////////////////////////////////////////////////////////////////////////////////
[componentInstances:cComponentManager]
instance[dataMemory].type=cDataMemory
 ; wave file input
instance[waveIn].type=cWaveSource
 ; audio framer
instance[frame].type=cFramer
 ; speech pre-emphasis (on a per frame basis as HTK does it)
instance[pe].type=cVectorPreemphasis
 ; apply a window function to pre-emphasised frames
instance[win].type=cWindower
 ; transform to the frequency domain using FFT
instance[fft].type=cTransformFFT
 ; compute magnitude of the complex fft from the previous component
instance[fftmag].type=cFFTmagphase
 ; compute Mel-bands from magnitude spectrum
instance[melspec].type=cMelspec
 ; compute MFCC from Mel-band spectrum
instance[mfcc].type=cMfcc
 ; compute log-energy from raw signal frames 
 ; (not windowed, not pre-emphasised: that's the way HTK does it)
instance[energy].type=cEnergy
 ; concat mfcc and energy, so we can compute delta and acceleration 
 ; coefficients of both features at the same tim
instance[cat].type=cVectorConcat
 ; compute delta coefficients from mfcc and energy
;instance[delta].type=cDeltaRegression
 ; compute acceleration coefficients from delta coefficients of mfcc and energy
;instance[accel].type=cDeltaRegression
 ; write the result to an ARFF parameter file
instance[arffsink].type=cArffSink
; run single threaded (nThreads=1)
; NOTE: a single thread is more efficient for processing small files, since multi-threaded processing involves more 
;       overhead during startup, which will make the system slower in the end
instance[lldsink].type=cCsvSink
; run single threaded (nThreads=1)
; NOTE: a single thread is more efficient for processing small files, since multi-threaded processing involves more 
;       overhead during startup, which will make the system slower in the end
nThreads=1
; do not show any internal dataMemory level settings 
; (if you want to see them set the value to 1, 2, 3, or 4, depending on the amount of detail you wish)
printLevelStats=0

/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////   component configuration  ////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
; the following sections configure the components listed above
; a help on configuration parameters can be obtained with 
;  SMILExtract -H
; or
;  SMILExtract -H configTypeName (= componentTypeName)
/////////////////////////////////////////////////////////////////////////////////////////////

[waveIn:cWaveSource]
 ; this sets the level this component writes to
 ; the level will be created by this component
 ; no other components may write to a level having the same name
writer.dmLevel=wave
 ; this defines a new commandline option "-I" or "-inputfile", which can be used to specify 
 ; the filename on the commandline instead of having it "hard-coded" in the config file
filename=\cm[inputfile(I){test.wav}:name of input file]
 ; mix stereo files down to mono for analysis
monoMixdown=1

[frame:cFramer]
reader.dmLevel=wave
writer.dmLevel=frames
noPostEOIprocessing = 1
copyInputName = 1
frameSize = 0.0250
frameStep = 0.010
frameMode = fixed
frameCenterSpecial = left

[pe:cVectorPreemphasis]
reader.dmLevel=frames
writer.dmLevel=framespe
k = 0.97
de = 0

[win:cWindower]
reader.dmLevel=framespe
writer.dmLevel=winframes
copyInputName = 1
processArrayFields = 1
 ; hamming window
winFunc = ham
 ; no gain, no offset
gain = 1.0
offset = 0

[fft:cTransformFFT]
reader.dmLevel=winframes
writer.dmLevel=fft
copyInputName = 1
processArrayFields = 1
inverse = 0

[fftmag:cFFTmagphase]
reader.dmLevel=fft
writer.dmLevel=fftmag
copyInputName = 1
processArrayFields = 1
inverse = 0
magnitude = 1
phase = 0

[melspec:cMelspec]
reader.dmLevel=fftmag
writer.dmLevel=melspec
copyInputName = 1
processArrayFields = 1
; htk compatible sample value scaling
htkcompatible = 1
nBands = 26
; use power spectrum instead of magnitude spectrum
usePower = 1
lofreq = 0
hifreq = 8000
specScale = mel
inverse = 0

[mfcc:cMfcc]
reader.dmLevel=melspec
writer.dmLevel=mfcc
copyInputName = 1
processArrayFields = 1
firstMfcc = 1
lastMfcc  = 12
cepLifter = 22.0
htkcompatible = 1

[energy:cEnergy]
reader.dmLevel=frames
writer.dmLevel=energy
nameAppend = energy
copyInputName = 1
processArrayFields = 0
htkcompatible=1
rms = 0
log = 1


[cat:cVectorConcat]
reader.dmLevel=mfcc;energy
writer.dmLevel=ft0
copyInputName = 1
processArrayFields = 0


/*[delta:cDeltaRegression]
reader.dmLevel=ft0
writer.dmLevel=ft0de
nameAppend = de
copyInputName = 1
noPostEOIprocessing = 0
deltawin=2
blocksize=1

[accel:cDeltaRegression]
reader.dmLevel=ft0de
writer.dmLevel=ft0dede
nameAppend = de
copyInputName = 1
noPostEOIprocessing = 0
deltawin=2
blocksize=1
*/

  //////////////////////////////////////////////////////////////////////
 ///////////////////  data output configuration  //////////////////////
//////////////////////////////////////////////////////////////////////

[arffsink:cArffSink]
reader.dmLevel=ft0
 ; do not print "frameNumber" attribute to ARFF file
frameIndex = 0
frameTime = 1
 ; name of output file as commandline option
filename=\cm[arffout(O){output.arff}:name of WEKA Arff output file]
 ; name of @relation in the ARFF file
relation=\cm[corpus{SMILEfeatures}:corpus name, arff relation]
printDefaultClassDummyAttribute = 0

[lldsink:cCsvSink]
reader.dmLevel = ft0
filename=\cm[lldoutput(D){?}:output csv file for LLD, disabled by default ?, only written if filename given]
instanceName=\cm[instname(N){unknown}:instance name]
append = \cm[appendlld{0}:set to 1 to append to the LLD output csv file, default is not to append]
timestamp = 1
number = 0
printHeader = 1
errorOnNoOutput = 1
 
 
 ; name of the current instance (usually file name of input wave file)
instanceName=\cm[instname(N){noname}:name of arff instance]
 ;; use this line instead of the above to always set the instance name to the
 ;; name of the input wave file
 ;instanceName=\cm[inputfile]
/*
 ; name of class label
class[0].name = class
 ; list of nominal classes OR "numeric"
class[0].type = \cm[classesA{numeric}:all classes for arff file attribute]
 ; the class label or value for the current instance
target[0].all = \cm[classlabelA(a){numeric}:instance class label]

class[1].name = label
 ; list of nominal classes OR "numeric"
class[1].type = \cm[classesV{unknown}:all classes for arff file attribute]
 ; the class label or value for the current instance
target[1].all = \cm[classlabelV(v){unknown}:instance class label]

class[2].name = emotion
 ; list of nominal classes OR "numeric"
class[2].type = \cm[classesE{unknown}:all classes for arff file attribute]
 ; the class label or value for the current instance
target[2].all = \cm[classlabelE(e){unknown}:instance class label]
*/
 ; append to an existing file, so multiple calls of SMILExtract on different
 ; input files append to the same output ARFF file
append=1
//////---------------------- END -------------------------///////

